/*
 * generated by Xtext 2.9.0
 */
package sysml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sysml.dml.BS;
import sysml.dml.D;
import sysml.dml.DI;
import sysml.dml.DmlPackage;
import sysml.dml.E;
import sysml.dml.F;
import sysml.dml.FC;
import sysml.dml.FP;
import sysml.dml.ID;
import sysml.dml.IS;
import sysml.dml.PARFORPARAMS;
import sysml.dml.PE;
import sysml.dml.PL;
import sysml.dml.S;
import sysml.dml.SPKV;
import sysml.dml.TAN;
import sysml.dml.TE;
import sysml.services.DmlGrammarAccess;

@SuppressWarnings("all")
public class DmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DmlPackage.BS:
				sequence_BS(context, (BS) semanticObject); 
				return; 
			case DmlPackage.D:
				sequence_D(context, (D) semanticObject); 
				return; 
			case DmlPackage.DI:
				sequence_DI(context, (DI) semanticObject); 
				return; 
			case DmlPackage.E:
				sequence_E(context, (E) semanticObject); 
				return; 
			case DmlPackage.F:
				sequence_F(context, (F) semanticObject); 
				return; 
			case DmlPackage.FC:
				sequence_FC(context, (FC) semanticObject); 
				return; 
			case DmlPackage.FP:
				sequence_FP(context, (FP) semanticObject); 
				return; 
			case DmlPackage.ID:
				sequence_ID(context, (ID) semanticObject); 
				return; 
			case DmlPackage.IS:
				sequence_IS(context, (IS) semanticObject); 
				return; 
			case DmlPackage.PARFORPARAMS:
				sequence_PARFORPARAMS(context, (PARFORPARAMS) semanticObject); 
				return; 
			case DmlPackage.PE:
				sequence_PE(context, (PE) semanticObject); 
				return; 
			case DmlPackage.PL:
				sequence_PL(context, (PL) semanticObject); 
				return; 
			case DmlPackage.S:
				sequence_S(context, (S) semanticObject); 
				return; 
			case DmlPackage.SPKV:
				sequence_SPKV(context, (SPKV) semanticObject); 
				return; 
			case DmlPackage.TAN:
				sequence_TAN(context, (TAN) semanticObject); 
				return; 
			case DmlPackage.TE:
				sequence_TE(context, (TE) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BS returns BS
	 *
	 * Constraint:
	 *     (singleS=S | s+=S+)
	 */
	protected void sequence_BS(ISerializationContext context, BS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DI returns DI
	 *
	 * Constraint:
	 *     ((id=ID b=IS? e=IS?) | clid=COMMANDLINE_NAMED_ID | cln=COMMANDLINE_POSITION_ID)
	 */
	protected void sequence_DI(ISerializationContext context, DI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     D returns D
	 *
	 * Constraint:
	 *     (f+=F | s+=S)+
	 */
	protected void sequence_D(ISerializationContext context, D semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E returns E
	 *
	 * Constraint:
	 *     (
	 *         ((op='!' | op='+' | op='-') t1=E) | 
	 *         (
	 *             t1=TE 
	 *             (
	 *                 (
	 *                     op='^' | 
	 *                     op='%*%' | 
	 *                     op='%/%' | 
	 *                     op='%%' | 
	 *                     op='*' | 
	 *                     op='/' | 
	 *                     op='+' | 
	 *                     op='-' | 
	 *                     op='>' | 
	 *                     op='>=' | 
	 *                     op='<' | 
	 *                     op='<=' | 
	 *                     op='==' | 
	 *                     op='!=' | 
	 *                     op='&' | 
	 *                     op='&&' | 
	 *                     op='|' | 
	 *                     op='||'
	 *                 ) 
	 *                 t2=E
	 *             )?
	 *         )
	 *     )
	 */
	protected void sequence_E(ISerializationContext context, E semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FC returns FC
	 *
	 * Constraint:
	 *     ((bif=BIF | id=ID) (pe+=PE pe+=PE*)?)
	 */
	protected void sequence_FC(ISerializationContext context, FC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FP returns FP
	 *
	 * Constraint:
	 *     (id=ID is=IS)
	 */
	protected void sequence_FP(ISerializationContext context, FP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.FP__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.FP__ID));
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.FP__IS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.FP__IS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFPAccess().getIdIDParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getFPAccess().getIsISParserRuleCall_2_0(), semanticObject.getIs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     F returns F
	 *
	 * Constraint:
	 *     ((name=ID i=PL r=PL? s+=S*) | (name=ID i=PL r=PL? (spkv+=SPKV spkv+=SPKV*)?))
	 */
	protected void sequence_F(ISerializationContext context, F semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ID returns ID
	 *
	 * Constraint:
	 *     (name='index.return' | name='lower.tail' | name=SINGLEID)
	 */
	protected void sequence_ID(ISerializationContext context, ID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IS returns IS
	 *
	 * Constraint:
	 *     (e1=E e2=E?)
	 */
	protected void sequence_IS(ISerializationContext context, IS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PARFORPARAMS returns PARFORPARAMS
	 *
	 * Constraint:
	 *     params+=PARAMS+
	 */
	protected void sequence_PARFORPARAMS(ISerializationContext context, PARFORPARAMS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PE returns PE
	 *
	 * Constraint:
	 *     (id=ID? e=E)
	 */
	protected void sequence_PE(ISerializationContext context, PE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PL returns PL
	 *
	 * Constraint:
	 *     (t+=TAN t+=TAN*)
	 */
	protected void sequence_PL(ISerializationContext context, PL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SPKV returns SPKV
	 *
	 * Constraint:
	 *     (k=ID v=STRING)
	 */
	protected void sequence_SPKV(ISerializationContext context, SPKV semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.SPKV__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.SPKV__K));
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.SPKV__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.SPKV__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSPKVAccess().getKIDParserRuleCall_0_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getSPKVAccess().getVSTRINGTerminalRuleCall_2_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     S returns S
	 *
	 * Constraint:
	 *     (
	 *         (src=STRING srcid=ID) | 
	 *         cwd=STRING | 
	 *         (ife=E is=BS es=BS?) | 
	 *         (fp=FP p=PARFORPARAMS s=BS) | 
	 *         (pf=FP p=PARFORPARAMS s=BS) | 
	 *         (we=E s=BS) | 
	 *         (di+=DI di+=DI* fc=FC) | 
	 *         (lhsdi=DI ((di+=DI e+=E) | e+=E)) | 
	 *         fc=FC
	 *     )
	 */
	protected void sequence_S(ISerializationContext context, S semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TAN returns TAN
	 *
	 * Constraint:
	 *     (t=MT name=ID)
	 */
	protected void sequence_TAN(ISerializationContext context, TAN semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.TAN__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.TAN__T));
			if (transientValues.isValueTransient(semanticObject, DmlPackage.Literals.TAN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DmlPackage.Literals.TAN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTANAccess().getTMTParserRuleCall_0_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getTANAccess().getNameIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TE returns TE
	 *
	 * Constraint:
	 *     (
	 *         e=E | 
	 *         i=INT | 
	 *         d=DOUBLE | 
	 *         s=STRING | 
	 *         b='TRUE' | 
	 *         b='FALSE' | 
	 *         f=FC | 
	 *         di=DI
	 *     )
	 */
	protected void sequence_TE(ISerializationContext context, TE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
